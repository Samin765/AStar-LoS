using System.Linq;
using Imported.StandardAssets.Vehicles.Car.Scripts;
using Scripts.Game;
using Scripts.Map;
using UnityEngine;

using System.Collections;
using System.Collections.Generic;
using System;
using Newtonsoft.Json;

using Imported.StandardAssets.Vehicles.Car.Scripts;
using Scripts.Map;
using Scripts.Vehicle;
using UnityEngine;
using UnityEngine.Analytics;
using System.Net.WebSockets;
using System.Reflection;




[RequireComponent(typeof(CarController))]
public class FollowPath
{
    private CarController m_Car;

    private DroneController m_Drone;

    private Rigidbody my_rigidbody;

    private List<Vector3> path;

    private List<Vector3> my_path;

    private List<Vector3> my_path2;

    private static ObstacleMapManager obstacleMapManager;

    private static ObstacleMap obstacleMap;

    private Vector3 old_target_pos;
    private Vector3 target_velocity;

    private float k_d = 0.7f;
    private float k_p = 0.1f;


    public FollowPath(CarController _car, Rigidbody _rigidBody, List<Vector3> _path, List<Vector3> _path2, ObstacleMapManager _ObstacleMapManager)
    {
        this.my_rigidbody = _rigidBody;
        this.m_Car = _car;
        this.path = _path;
        this.my_path = _path;
        this.my_path2 = _path2;
        obstacleMapManager = _ObstacleMapManager;
        obstacleMap = obstacleMapManager.ObstacleMap;

        this.old_target_pos = path[0];

        if (m_Car == null)
        {
            Debug.LogError("CarController component not found on the GameObject.");
        }
            drive = true;

    }

    public FollowPath(DroneController _drone, Rigidbody _rigidBody, List<Vector3> _path, ObstacleMapManager _ObstacleMapManager)
    {
        this.my_rigidbody = _rigidBody;
        this.m_Drone = _drone;
        this.path = _path;
        obstacleMapManager = _ObstacleMapManager;
        obstacleMap = obstacleMapManager.ObstacleMap;

        this.old_target_pos = path[0];

        if (m_Drone == null)
        {
            Debug.LogError("CarController component not found on the GameObject.");
        }

    }

    public FollowPath(CarController _car, Rigidbody _rigidBody, ObstacleMapManager _ObstacleMapManager)
    {
        this.my_rigidbody = _rigidBody;
        this.m_Car = _car;

        obstacleMapManager = _ObstacleMapManager;
        obstacleMap = obstacleMapManager.ObstacleMap;



        if (m_Car == null)
        {
            Debug.LogError("CarController component not found on the GameObject.");
        }

    }


    public Vector3Int test()
    {
        return obstacleMap.mapGrid.WorldToCell(Vector3.zero);
    }

    public void newPath(List<Vector3> newPath)
    {
        this.path = newPath;
    }



    public void Follow()
    {
        if (path == null) return;

        if (path.Count > 0)
        {
            Vector3 target_position;
            Vector3 target_position1;
            k_p = 30f;
            k_d = 0.1f * k_p;

            if (path.Count > 1)
            {
                target_position = path[1];
            }
            else if (path.Count == 1)
            {
                target_position = path[0];
            }
            else
            {
                target_position = m_Car.transform.position;
            }

            Vector3 myLocalPosition = obstacleMap.mapGrid.WorldToLocal(my_rigidbody.transform.position);
            target_velocity = (target_position - old_target_pos) / Time.fixedDeltaTime;
            old_target_pos = target_position;

            Vector3 position_error = target_position - myLocalPosition;
            Vector3 velocity_error = target_velocity - my_rigidbody.velocity;
            Vector3 desired_acceleration = k_p * position_error + k_d * velocity_error;


            float steering = Vector3.Dot(desired_acceleration, my_rigidbody.transform.right);
            float acceleration = Vector3.Dot(desired_acceleration, my_rigidbody.transform.forward);

            if (Mathf.Abs(Vector3.Distance(myLocalPosition, target_position)) < 0.5)
            {
                path.RemoveAt(0);
            }
            //Debug.Log($"Steering: {steering} Acceleration: {acceleration}");
            m_Car.Move(steering, acceleration, acceleration, 0f);
        }
    }

    public void FollowPoint(Vector3 targetPosition, int gate)
    {
        k_p = 0.2f;
        k_d = 0.1f * k_p;
        if (targetPosition == null)
        {
            Debug.LogError("Target position is null.");
            return;
        }

        float adjustmenFactor = CalculateAdjustmentFactorCar(gate);

        Vector3 myLocalPosition = obstacleMap.mapGrid.WorldToLocal(my_rigidbody.transform.position);

        // Calculate desired velocity towards the target position
        Vector3 targetVelocity = (targetPosition - myLocalPosition) / Time.fixedDeltaTime;

        // Calculate position error and velocity error
        Vector3 positionError = targetPosition - myLocalPosition;
        Vector3 velocityError = targetVelocity - my_rigidbody.velocity;

        // Calculate desired acceleration using proportional and derivative gains
        Vector3 desiredAcceleration = k_p * positionError + k_d * velocityError;

        // Calculate steering angle and acceleration
        float steering = Vector3.Dot(desiredAcceleration, my_rigidbody.transform.right);
        float acceleration = Vector3.Dot(desiredAcceleration, my_rigidbody.transform.forward) * adjustmenFactor;

        // Move the car based on the calculated steering angle and acceleration
        m_Car.Move(steering, acceleration, acceleration, 0f);
        GlobalVariables.CurrentCarPos[GlobalVariables.carIDMap[m_Car.GetInstanceID()]] = m_Car.transform.position;
    }

    private int targetIndexCar = 0;
    private int targetIndexCar2 = 0;
    private Vector3 Old_targetPosCar;
    public Vector3 targetPosCar;

    public float next_taget_index = 9f;




    public bool drive;
    public bool follow;

    private Vector3 old_target_posCar;
    private Vector3 target_velocityCar;

    Vector3 target_positionCar;

    public void setDrive(bool action)
    {
        drive = action;
    }

    public void setFollow(bool action)
    {
        follow = action;
    }

    public void setTarget(Vector3 target)
    {
        target_positionCar = obstacleMap.mapGrid.WorldToLocal(target);
    }



    public void FollowCar()
    {
        {
        
        Vector3 target_position;


        Vector3 myLocalPosition = obstacleMap.mapGrid.WorldToLocal(m_Car.transform.position);
        //y is 0
        myLocalPosition.y = 0;
        
      
       
        
            target_position = path[0];
            target_velocity = (target_position - old_target_pos) / Time.fixedDeltaTime;
        

        old_target_pos = target_position;

        // a PD-controller to get desired acceleration from errors in position and velocity
        Vector3 position_error = target_position - myLocalPosition;
        Vector3 velocity_error = target_velocity - my_rigidbody.velocity;
        Vector3 desired_acceleration = k_p * position_error + k_d * velocity_error;

        float steering = Vector3.Dot(desired_acceleration, m_Car.transform.right);
        float acceleration = Vector3.Dot(desired_acceleration, m_Car.transform.forward);

        Debug.DrawLine(target_position, target_position + target_velocity, Color.red);
        Debug.DrawLine(myLocalPosition, myLocalPosition + my_rigidbody.velocity, Color.blue);
        Debug.DrawLine(myLocalPosition, myLocalPosition + desired_acceleration, Color.black);
        float mydistance = Vector3.Distance(myLocalPosition, target_position);
        if (mydistance < 1f)
        {
            path.RemoveAt(0);
            this.path.RemoveAt(0);

        }
        if(my_rigidbody.velocity.sqrMagnitude <2f)
        {
            m_Car.Move(-1f, -1f, 1f, 0f);
            path.RemoveAt(0);
            this.path.RemoveAt(0);
            target_position = path[0];
            return;
           
        }

        // this is how you control the car
        Debug.Log("Steering:" + steering + " Acceleration:" + acceleration);
        flo
